# FreeBSD 14 中有关 TCP 的更新

已经大约 3 年半了，自从我上次报告我专注的 FreeBSD 项目领域，即 TCP 协议的实现。对于那些不了解的人来说，FreeBSD 不只是有一个 TCP 堆栈，而是有多个，开发主要集中在 RACK 和基础堆栈中。目前，默认使用的是基础堆栈，这个堆栈长期以来是从 BSD4.4 派生和发展而来的。此外，自 2018 年以来，我们已经有了完全重构的堆栈（“RACK 堆栈” - 以最近确认机制命名），它提供了许多基础堆栈所缺乏的先进功能。例如，RACK 堆栈提供了高精度的调度能力。也就是说，堆栈可以计时发送数据包，并平衡网络资源的消耗。相比之下，如果应用程序向基础堆栈提交突发的数据传输请求，有时这些数据会在接近线路速率的大量突发中发送出去（即界面的速度，前提是 CPU 和内部总线不是瓶颈）。这种情况尤其明显发生在应用程序从上次应用程序 IO 暂停到几十毫秒之间的短暂暂停时。（关于 RACK 堆栈的进一步细节超出了本文的范围，可以在迈克尔·图克森和兰德尔·斯图尔特的附带文章中阅读。）

这里，我想突出一些已经添加到基础堆栈中的新功能 - 其中许多默认已启用，但有些可能需要专门激活。每个功能都将详细描述，这些细节可能有助于改善网络体验。

总体而言，自 FreeBSD 13.0 发布以来，到传统上承载所有传输协议的 sys/netinet 目录已有大约 1033 个提交。这概述了基础堆栈的部分更改，其中功能得到了改进：

## 比例速率降低

首次引入基本堆栈的第一个特性是 PRR - 比例速率减少（RFC6937）。为了在高层次上理解 PRR，让我们首先了解 SACK 在丢失恢复期间的工作原理。标准 SACK 丢失恢复的一个问题在于，在进入丢失恢复时调整拥塞窗口（例如，使用 NewReno 时调整为拥塞开始时值的 50%，使用 Cubic 时为 70%），在单个数据包丢失后，最初不允许任何数据包被发送，因为初始半数（NewReno）或窗口的 30%内（Cubic）等待 ACK 返回。一旦达到了这个限制，每个接收的 ACK 都将引发一个新数据包发送，但这可能以一种有效速率发生，超过了网络中的拥塞点。初始的静默期可以用来排空队列，并允许随后的传输比理想速度更快。通常这种行为会导致随后的丢失（甚至重新传输数据包的丢失 - 关于此后将会详细介绍）。

为了快速调整有效的发送速率 - 并且在存在多个数据包丢失或甚至丢失 ACK 数据包时更加恰当地处理 - PRR 将计算每次新的接收到的 ACK 应发送多少数据，并在那个时候发送出相应数量的满尺寸数据包。在利用 NewReno 减少拥塞窗口到一半并且只有单个数据包丢失的简单示例中，这将导致每接收到两个 ACK 就发送一个新的数据包。因此，发送速率将即时调整到之前的一半 - 阻止拥塞设备过载。在存在多个数据丢失或 ACK 丢失的情况下，PRR 可能在最终收到 ACK 时发送多于一个数据包，弥补了这些错失的发送机会。总体而言，这种行为可以确保在窗口结束时（RTT）进行丢失恢复时，有效的拥塞窗口尽可能接近预期的拥塞窗口，并且不会错过任何传输机会，即使在存在多个数据包丢失或 ACK 丢失等问题情况下也是如此。

希望几幅图表能更好地解释这个细节。下面，我们有时间序列图，可以从 wireshark 或 tcptrace 和相关的 xplot 组合中获得。小的蓝色垂直条表示何时发送了覆盖数据序列的特定数据包 - 如左轴所示。下方更横向的绿色线表示接收方连续接收到的数据。红色的垂直线表示传输给接收方的任何不连续数据范围。

![](https://freebsdfoundation.org/wp-content/uploads/2024/02/scheffenegger_fig1.png)

### 没有 SACK 或 PRR 的 Cubic，经典 NewReno 丢失恢复

请注意，每个窗口（或往返时间）内只能恢复一个数据包，并且在接收应用程序处理额外数据之前，产生的水平绿线拉伸指示延迟。

![](https://freebsdfoundation.org/wp-content/uploads/2024/02/scheffenegger_fig2.png)

### 具有 SACK 的立方体，但没有 PRR

正如这个例子所示，SACK 显着改善了情况，因为所有丢失的数据包（通常）可以在一个 RTT 内重新传输。但是，请注意稍后每个 ACK 上发送数据的暂停和恢复。此行为以有效速率驱动数据，导致一些数据包被丢入网络。通常，这会导致一个或多个重传到达得太快，网络会丢弃重传。那时唯一的补救措施就是等待重传超时（RTO）。

![](https://freebsdfoundation.org/wp-content/uploads/2024/02/scheffenegger_fig3.png)

### 具有 SACK（6675）和 PRR 的立方体

在这里描绘的 PRR 改进是微妙的。先前，半个窗口没有发送数据，然后在旧的、可能过高的速率下发送第二半窗口，PRR 在每隔一个接收到的 ACK 左右注入数据包，直到达到新的发送速率，然后在几乎每个后续的入站 ACK 上。这有助于降低重传的有效发送速率，减少网络丢弃的可能性。更少的 RTO 和改善的延迟是其结果。

此处显示的图表并不完全正确，但试图传达 PRR“摇摆”适当地发送的数据包，覆盖接收的 ACK——在这种情况下，平均每个 ACK 发送 0.7 个数据包，包括可能被网络丢弃的数据包。

最后的更新是，除非在丢失恢复中有额外的损失，否则 PRR 现在会自动切换到不太保守的模式。 这在丢失恢复期间有效地提高了传输速度，类似于在拥塞避免阶段的正常操作期间会发生的情况。 PRR 最好与 SACK 一起使用（自然），但即使只有非 SACK 重复 ACK 可用时也有效。 即使仅有 ECN 反馈，PRR 也可以改进传输时机。

## SACK 处理

最近几年，基本堆栈对于 RFC6675 中规定的 SACK 丢失恢复的遵守已经得到改进。 但是，虽然 RFC6675 中有关网络中尚未完成多少数据的估计的部分已得到改进，但其他方面仍有缺失。

此空间中的改进现在包括使用所谓的救援重传-这是 RACK 堆栈中实现的 Tail-Loss Probe 的先驱。简而言之，当转移的最后几个数据包丢失以及较早丢失数据包时，堆栈可以检测问题，并将重新传输最终数据包以执行及时的丢失恢复。

通过在处理任何传入 SACK 块时实施额外的会计，堆栈可以更好地跟踪特定数据包是否应该通过接收或很可能被丢弃而离开网络。

最后一个增强是跟踪网络可能还会丢弃的重传数据包，但与 RACK 使用时间域不同，基本堆栈考虑序列域。虽然这种丢失的重传检测未在 RFC 系列中指定，但对于减少流完成时间/IO 服务响应时间的任何请求-响应（例如，RPC）协议使用 TCP 堆栈都是极其宝贵的。追踪和恢复丢失的重传目前不会默认发生。在 FreeBSD 14 中，可以通过 net.inet.tcp.do_lrd 激活此功能-但在 FreeBSD 15 中，这将转移到 net.inet.tcp.sack.lrd 并默认启用。

总体而言，这些变化使基础堆栈在 IP 网络中频繁遇到的病态拥塞问题期间更具弹性。

![](https://freebsdfoundation.org/wp-content/uploads/2024/02/schefenegger_fig4.jpg)

最后，基础堆栈（以及 RACK 堆栈）在接收到虚假重复数据包时创建 DSACK（RFC2883）响应。虽然接收此类 DSACK 信息不会影响堆栈行为，但将其提供给远程发送方可能使发送方更好地调整特定网络路径的行为——例如，Linux 可能会增加 dupthresh 或检测到由于路径往返时间（RTT）的急剧增加而引起的虚假重传。

## 记录和调试

几十年来，基础堆栈积累了几种不同的机制，可以在活动系统上进行调试。其中一个鲜为人知的工具 trpt 及其支持在 FreeBSD 14 中被移除。但仍然存在许多其他选项（如 dtrace、siftr、bblog 等）。

黑匣子日志记录是在 RACK 堆栈中引入的，并逐步扩展到覆盖更多基础堆栈。正在准备工具，用于从运行中的系统中提取内部状态变化，以及从核心转储中提取它们本身的数据包跟踪。（见 https://github.com/Netflix/tcplog_dumper 和 https://github.com/Netflix/read_bbrlog）

## Cubic

如前一篇文章中所描述，TCP Cubic 是几乎在所有地方使用的事实标准拥塞控制算法。最近，Cubic 也成为 FreeBSD 的默认选项 - 无论使用哪种 TCP 堆栈。

这里的一个显著扩展是添加 HyStart++。当 TCP 会话启动时，拥塞控制机制会在称为慢启动的阶段快速提升带宽。传统上，慢启动阶段在收到拥塞的第一个迹象（数据包丢失，或可能是显式拥塞通知(ECN)反馈）时结束。使用 HyStart++，它作为 Cubic 模块的一部分实现，并且始终启用，RTT 被监控。当 RTT 开始上升时 - 可能是因为网络队列开始形成 - 进入了一个不那么激进的阶段（保守慢启动），并且仍然监控 RTT，因为任何基于时间的信号都极其难以可靠获取。如果事实证明 RTT 在这种保守慢启动阶段下降，将恢复常规慢启动。如果不是，CSS 中的较不激进的发送速度限制了所谓的超限 - 这是由于不可避免的损失导致的可能需要恢复的数据量。

## 准确的显式拥塞通知

如前所述，ECN 是一种机制，用于避免数据包丢失作为唯一指示拥塞事件的信号。过去十年，互联网工程任务组(IETF)投入了大量的努力来改善这种信号。最初，ECN 被视为与数据包丢失相同的信号，但发现频繁信号具有不同语义可以更好地维持在各种带宽范围内保持浅层(快速)队列。完整的架构被命名为低延迟、低丢包、可扩展(L4S)。虽然当前 FreeBSD 中并非所有的组件都准备好实现适当的“TCP Prague”实现，但许多单独的特性 - 比如 DCTCP 拥塞控制模块以及这里相关的精准 ECN (AccECN) - 现在已经成为 FreeBSD 14 中的一个部分。

在经典 ECN 中，每轮往返时间(RTT)只能传递一个拥塞经验标记。这需要由拥塞控制模块进行粗糙的管理。事实上，当在 RFC3168 模式下操作时，CE 标记被视为与数据包丢失指示相同，用于调整 TCP 带宽。相比之下，使用 AccECN，接收方可以将任意数量的显式拥塞标记传回数据发送方。这使得可以从网络中提取出更加调制和细粒度的信号。这在需要使用具有中间交换机修改的更为激进标记阈值的 DCTCP 的环境中变得相关。这也是低延迟、低丢包、可扩展(L4S)架构(也称为 TCP Prague)的关键部分之一。

## 认证和安全

最近，RACK 栈获得了完全处理 TCP 数据包 MD5 认证的能力。这是一个改进，允许使用 BGP 与 RACK 栈 - 这是使 RACK 栈在任何通用情况下都能完全发挥作用的又一步。

长期以来，在 RFC7323（RFC1323）的两个特性之间存在着紧密的耦合 - 窗口缩放和时间戳选项。在这个领域，现在允许其中任何一个独立启用，而默认情况下仍允许两者同时活动。现在可以通过设置 net.inet.tcp.rfc1323 不仅为 on（1）或 off（0），还可以为 2（仅窗口比例）和 3（仅时间戳）来实现。此外，根据 RFC7323 的规定，现在可以通过要求在任何情况下正确使用 TCP 时间戳来进一步保护 TCP 会话。这可以通过将 net.inet.tcp.tolerate_missing_ts 设置为 0 来实现。

## 接下来是什么？

尽管 TCP 功能各方面的改进已经进入了收益递减阶段，但仍在讨论进一步的增强。

例如，RFC2018 的勘误（选择性确认）现在允许在重传超时（RTO）期间保留信息，而以前不行。最初标准的主要动机是允许接收方“反悔”。除非明确确认，否则后续数据可能会因内存压力等原因被丢弃。实际上，这种反悔几乎不会发生，但在 SACK 丢失恢复阶段经常发生重传超时。保留这些信息使得即使在 RTO 之后也能更高效地进行重传。挑战在于基础堆栈在重传超时后与其他方面有隐式紧密耦合，比如从非常小的拥塞窗口开始的慢启动。此外，需要评估此更改在 RTO 后的影响，将一些额外的能力引入 dummynet 路径仿真器，以更可控的方式建模丢包。

RICHARD SCHEFFENEGGER 自 2020 年 4 月以来一直是 FreeBSD 提交者，他致力于改进 TCP 堆栈的功能和功能，主要集中在慢路径（丢失恢复，拥塞控制处理），并积极开发增强功能，如与 IETF 的准确 ECN。
