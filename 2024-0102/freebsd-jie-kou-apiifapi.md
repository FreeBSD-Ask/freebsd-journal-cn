# FreeBSD 接口 API（IfAPI）

 由 JUSTIN HIBBITS

一些人可能知道，Juniper 使用自己定制的网络堆栈与 FreeBSD-很久以前分叉-因此它只是表面上类似于当前的 FreeBSD 网络堆栈。当前的 FreeBSD 堆栈中存在的状态在 Junos 中不存在，反之亦然。

## 为什么和如何

Junos 很大，非常庞大。更新 FreeBSD 是一项艰巨的任务。为了使其更容易，Juniper 将 FreeBSD 组件拆分到自己独立的存储库中，将 Juniper 的增强功能留在其单独的存储库中。这导致了一个困境-我们如何在 FreeBSD 中保留驱动程序，但网络堆栈放在其他地方？作为 FreeBSD 拆分项目的一部分，原始的 DrvAPI 诞生了。有了这个，驱动程序可以存在于 FreeBSD 存储库中，同时保持 Junos 网络堆栈独立。

但是什么是 netstack？我们在 netstack 和其他部分之间划定界限的依据是什么？最初的方法是“sys/目录中所有以 net 为前缀”，这方法效果不错。然而，最近添加了 netlink 组件，从概念上讲并不属于网络堆栈的一部分，所以被划去了。现在 netstack 包括 net 、 net80211 、 netgraph 、 netinet 、 netinet6 和 netpfil 。只保留网络堆栈的细节也使核心内核的细节隐藏起来。为了适应 IfAPI，需要对内核的其他部分进行一些更改，包括 NFS 无根（引导）和 mbuf 处理。

## 设计

IfAPI 的当前设计只是访问器和迭代器。选择这种方式主要是为了转换驱动程序并隐藏 struct ifnet ，尽管这并不是最佳的方法。转换主要是机械化的，并且 Juniper 提供了一个shell脚本来处理大部分转换工作。显然，这可能会漏掉一些转换，例如 ifp 是另一个结构的成员或者命名为其他名称，如 foo_ifp ，但它确实处理了大多数情况。

至于迭代器，最初的实现基于 Gleb Smirnoff 的 if_foreach_lladdr() ，在迭代给定类型时使用回调。这被应用于 if_addr 和 if_t ，在接口上进行迭代仅迭代当前 VNET。最近添加了新的迭代器 API，允许使用更传统的循环进行迭代；要求您必须调用 if_iter_finish() 或 ifa_iter_finish() 清理设置为迭代准备的任何状态，包括释放实现可能分配的任何内存（FreeBSD 网络堆栈未执行此操作，但其他堆栈可能执行）。

## 益处

将设备驱动程序与网络堆栈详细信息分离，带来了超出 Juniper 源代码管理的益处。通过稳定的 ABI，单个设备驱动程序可以与多个不同的网络堆栈一起使用。例如，数据中心中所有计算机的一个映像可以在启动时根据执行配置选择不同的网络堆栈；一些设备使用高性能限制堆栈，而其他设备使用完整堆栈，所有设备均使用相同的网络驱动程序。

另一个更小的好处是，驱动程序更改和网络栈更改可以同时发生，而互不影响。在引入 IfAPI 之前，对 struct ifnet 进行的任何更改都需要重新构建所有设备驱动程序。未来，由于 struct ifnet 完全是私有的，对结构的任何更改仅需要重新构建直接引用它的文件，从而缩短调试周期。

## 接下来在哪里？

IfAPI 只是第一步，还有更多工作要做才能正确地将网络堆栈抽象化。Gleb Smirnoff 建议使用 KOBJ 接口来实现更易插拔的网络堆栈，将网络堆栈与其余部分完全解耦。这甚至可以允许在运行时替换网络堆栈（ kldunload/kldload ）。进一步地，我们可能允许使用多个网络堆栈，为不同的设备分配不同的堆栈。有了这个，甚至可以动态地在不同的网络堆栈之间移动接口。

## 结论

IfAPI 只是从网络驱动程序中解耦网络堆栈内部工作的第一阶段。通过进一步的工作，可以使用多个网络堆栈，并且甚至可以重新加载网络堆栈。

JUSTIN HIBBITS 在 2011 年因其对 PowerPC 的痴迷而被信任得到 FreeBSD 的提交权限。从那时起，他主要专注于 PowerPC 和其他嵌入式架构。他目前在 Juniper Networks 工作，负责所有与 FreeBSD 内核相关的工作，并继续他对低级开发和异构架构的热情。
